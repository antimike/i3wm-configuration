#!/usr/bin/env -S python3 -W ignore::DeprecationWarning
# -*- python -*-

"""Simple dimmer for xss-lock.

It dim the screen using a provided delay and display a countdown. It
will stop itself when the locker window is mapped.
"""

# It assumes we are using a compositor.

import gi

gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, Gdk, GLib
import cairo
import argparse
import threading
from Xlib import display, X
from Xlib.error import BadWindow
from Xlib.protocol.event import MapNotify


def watch_for_locker(locker):
    xdisplay = display.Display()
    root = xdisplay.screen().root
    root.change_attributes(event_mask=X.SubstructureNotifyMask)
    while True:
        event = xdisplay.next_event()
        if event.type != X.MapNotify:
            continue
        try:
            wmclass = event.window.get_wm_class()
        except error.BadWindow:
            continue
        if wmclass and wmclass[1] == locker:
            GLib.idle_add(Gtk.main_quit)
            return


def on_realize(widget):
    window = widget.get_window()
    window.set_override_redirect(True)


def on_draw(widget, event, options, elapsed):
    def dim(once=False):
        cr = Gdk.cairo_create(window)

        # Background
        delta = options.end_opacity - options.start_opacity
        current = elapsed[0] / options.delay
        opacity = delta * current + options.start_opacity
        cr.set_source_rgba(0, 0, 0, opacity)
        cr.set_operator(cairo.OPERATOR_SOURCE)
        cr.paint()

        # Remaining time
        remaining = str(round(options.delay - elapsed[0]))
        wwidth, wheight = widget.get_default_size()
        cr.set_source_rgba(1, 1, 1, opacity)
        cr.select_font_face(
            options.font, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD
        )
        cr.set_font_size(wheight // 4)
        _, _, twidth, theight, _, _ = cr.text_extents(remaining)
        cr.move_to(wwidth // 2 - twidth // 2, wheight // 2 + theight // 2)
        cr.show_text(remaining)

        # Rearm timer
        if not once:
            elapsed[0] += options.step
            if elapsed[0] <= options.delay:
                GLib.timeout_add(options.step * 1000, dim)

    window = widget.get_window()
    if not elapsed:
        # First time we are called.
        elapsed.append(0)
        dim()
    else:
        # Timers already running, just repaint
        dim(once=True)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    add = parser.add_argument
    add("--start-opacity", type=float, default=0.2, help="initial opacity")
    add("--end-opacity", type=float, default=1, help="final opacity")
    add("--step", type=float, default=0.1, help="step for changing opacity")
    add("--delay", type=float, default=10, help="delay from start to end")
    add("--font", default="DejaVu Sans", help="font for countdown")
    add("--locker", default="i3lock", help="quit if window class detected")
    options = parser.parse_args()

    gdisplay = Gdk.Display.get_default()
    for i in range(gdisplay.get_n_monitors()):
        geom = gdisplay.get_monitor(i).get_geometry()
        once = []

        window = Gtk.Window()
        window.set_wmclass("dimmer", "Dimmer")
        window.set_app_paintable(True)
        window.set_type_hint(Gdk.WindowTypeHint.SPLASHSCREEN)
        window.set_visual(window.get_screen().get_rgba_visual())

        window.set_default_size(geom.width, geom.height)
        window.move(geom.x, geom.y)

        window.connect("draw", on_draw, options, [])
        window.connect("delete-event", Gtk.main_quit)
        window.connect("realize", on_realize)

        window.show_all()

    watcher = threading.Thread(
        target=watch_for_locker, args=(options.locker,), daemon=True
    )
    watcher.start()
    Gtk.main()
